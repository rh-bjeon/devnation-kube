= Volumes & Persistent Volumes

컨테이너에는 기본적으로 임시 스토리지가 있습니다. 
이 임시 스토리지는 Pod 간에 공유할 수 없으며, 컨테이너를 삭제하면 해당 컨테이너 내의 모든 파일과 데이터도 삭제됩니다. 
이는 데이터베이스 컨테이너와 같이 데이터를 유지해야 하는 컨테이너에 문제가 될 수 있습니다.

데이터를 보존하기 위해 컨테이너는 영구 스토리지 볼륨을 사용합니다.

일반적으로 각 Kubernetes 클러스터에 여러 스토리지 유형을 사용할 수 있습니다.
다음 목록은 일반적으로 사용되는 일부 스토리지 볼륨 유형 및 사용 사례이며 전체는 아닙니다.

* **Local**: 호스트의 디스크 또는 파티션과 같은 로컬 스토리지 장치를 Pod에 마운트 합니다. Pod가 다른 노드로 이동하면 기존 데이터를 사용할 수 없습니다. 
* **hostpath**: 호스트의 파일 또는 디렉터리를 Pod에 마운트합니다. hostPath 볼륨을 사용하려면 컨테이너가 호스트 파일 시스템에 접근할 수 있는 권한이 필요하므로 보안 위험이 있습니다. (주요 용도: 로그 수집, 시스템 소켓 접근 등)
* **NFS**: NFS를 통해 여러 Pod에서 동시에 액세스할 수 있는 공유 데이터를 제공합니다. 
* **emptyDir**: 임시 데이터, 캐시 등을 위해 임시로 빈 디렉터리를 제공합니다. 같은 Pod 내 여러 컨테이너가 공유 가능하며, Pod가 삭제되면 자동으로 삭제됩니다. (주요 용도: 캐싱, 일시적인 데이터 저장)
* **awsElasticBlockStore**
* **azureDisk**
* **ephfs**


== 사전 준비

=== 프로젝트 생성

올바른 프로젝트에 있는지 확인하세요.



[#kubectl-deploy-app]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc new-project volume-%userid%
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
namespace/volume-%userid% created
----

NOTE: `oc new-project volume-%userid%` : volume-%userid%라는 새 프로젝트(프로젝트)를 생성합니다.



[#kubectl-deploy-app]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc project volume-%userid%
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Now using project "volume-%userid%" on server "https://172.30.0.1:443".
----

NOTE: `oc project volume-%userid%` : 현재 활성화된 컨텍스트의 기본 프로젝트를 volume-%userid%로 변경합니다.



프로젝트에서 아무것도 실행되고 있지 않은지 확인하세요.

[#no-resources-resource]
[.console-input]
[source, bash]
----
oc get all
----

[.console-output]
[source,bash]
----
No resources found in myspace namespace.
----


=== Watch

* *Terminal#2에서 작업*


[.console-input]
[source,bash,subs="+macros,+attributes"]
----
watch -n 1 "oc get pods -o wide \
  | awk '{print \$1 \" \" \$2 \" \" \$3 \" \" \$5 \" \" \$7}' | column -t"
----


TIP: `-o wide` 옵션을 사용하면 Pod가 예약된 노드를 볼 수 있습니다. +
줄이 너무 길어지는 것을 방지하기 위해 `awk` 와 `column` 을 사용하여 원하는 열만 가져오고 형식을 지정합니다.


== Volumes

'Volumes'의 두 가지 예부터 시작해 보겠습니다.


=== EmptyDir

'emptyDir' 볼륨은 Pod가 노드에 할당될 때 처음 생성되고 해당 Pod가 해당 노드에서 실행되는 동안 존재합니다. 이름에서 알 수 있듯이 처음에는 비어 있습니다. 동일한 Pod에 있는 모든 컨테이너는 읽고 쓸 수 있습니다.  동일한 `emptyDir` 볼륨. Pod가 다시 시작되거나 제거되면 `emptyDir`의 데이터가 영원히 손실됩니다.


두 개의 엔드포인트(파일에 콘텐츠를 쓰는 엔드포인트와 해당 파일에서 콘텐츠를 검색하는 엔드포인트)를 노출하는 서비스를 배포해 보겠습니다. 

[source, yaml]
----
apiVersion: v1
kind: Pod #<.>
metadata:
  name: myboot-demo
spec:
  containers:
  - name: myboot-demo
    image: quay.io/rhdevelopers/myboot:v4
    
    volumeMounts:
    - mountPath: /tmp/demo #<.>
      name: demo-volume #<.> 

  volumes:
  - name: demo-volume
    emptyDir: {}
----
<.> 이는 'Deployment'가 아닌 'Pod'입니다.
<.> 이 마운트 지점이 Pod에 표시되는 위치입니다.  아래를 참조하세요 
<.> 이는 우리가 정의한 볼륨의 이름과 일치해야 합니다. 이 경우 파일 하단에 바로 정의됩니다.

`volumes` 섹션에서는 볼륨을 정의하고, `volumeMounts` 섹션에서는 볼륨이 컨테이너 내부에 마운트되는 방법을 정의합니다.


[.console-input]
[source,bash,subs="+macros,+attributes"]
----
cat <<EOF | oc create -f -
apiVersion: v1
kind: Pod #<.>
metadata:
  name: myboot-demo
spec:
  containers:
  - name: myboot-demo
    image: quay.io/rhdevelopers/myboot:v4
    
    volumeMounts:
    - mountPath: /tmp/demo #<.>
      name: demo-volume #<.> 

  volumes:
  - name: demo-volume
    emptyDir: {}
EOF
----


그런 다음 Watch 창에서 다음과 같은 내용을 볼 수 있습니다.

* *Terminal#2에서 확인*

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME         READY  STATUS             AGE  NODE
myboot-demo  0/1    ContainerCreating  9s   devnation
----


Pod가 실행되면 컨테이너에 실행해 보겠습니다.

[.console-input]
[source,bash]
----
oc exec -ti myboot-demo -- /bin/bash
----

그리고 컨테이너에 'exec'가 들어가면 다음 명령을 실행합니다.

[.console-input]
[source,bash]
----
curl localhost:8080/appendgreetingfile
curl localhost:8080/readgreetingfile
----

NOTE: 해당 명령어는 Greetingfile에 특정 문구를 추가합니다.

아래의 값이 반환됩니다.

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Jambo
----

이 경우 `emptyDir`은 `/tmp/demo`로 설정되었으므로 `ls`를 실행하여 디렉터리 내용을 확인할 수 있습니다.


[.console-input]
[source,bash]
----
ls /tmp/demo
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
greeting.txt
----


==== EmptyDir Ephemerality

아직 닫지 않았다면 컨테이너의 셸을 닫습니다.


[.console-input]
[source,bash]
----
exit
----


그리고 Pod를 삭제합니다.

[.console-input]
[source,bash]
----
oc delete pod myboot-demo
----

[IMPORTANT]
====
Pod를 다시 배포하기 전에 Pod가 완전히 삭제될 때까지 기다려야 합니다.
====

그런 다음 동일한 서비스를 다시 배포하는 경우:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
cat <<EOF | oc create -f -
apiVersion: v1
kind: Pod #<.>
metadata:
  name: myboot-demo
spec:
  containers:
  - name: myboot-demo
    image: quay.io/rhdevelopers/myboot:v4
    
    volumeMounts:
    - mountPath: /tmp/demo #<.>
      name: demo-volume #<.> 

  volumes:
  - name: demo-volume
    emptyDir: {}
EOF
----

그리고 `실행 중` 상태에서 Pod에 `exec`를 입력하면 다음과 같습니다.

[.console-input]
[source,bash]
----
oc exec -ti myboot-demo -- /bin/bash
----


새 Pod에 마운트 지점의 내용을 나열해 보겠습니다.

[.console-input]
[source,bash]
----
ls /tmp/demo
----

디렉터리 콘텐츠가 비어 있음을 알 수 있습니다. 이는 마지막 Pod로 생성한 파일이 Pod가 삭제될 때 삭제되었음을 의미합니다.

[.console-output]
[source,bash]
----
root@myboot-demo:/app# 
----

Pod의 명령어창을 종료합니다.

[.console-input]
[source,bash]
----
exit
----

이제 Pod를 삭제하세요.

[.console-input]
[source,bash]
----
oc delete pod myboot-demo
----


==== EmptyDir Sharing in Pod

`emptyDir`은 동일한 Pod의 컨테이너 간에 공유됩니다.  동일한 'emptyDir' 볼륨을 마운트하는 동일한 Pod에 두 개의 컨테이너를 생성하는 Deployment를 살펴보겠습니다.


[.console-output]
[source,yaml]
.{quick-open-file}
----
apiVersion: v1
kind: Pod
metadata:
  name: myboot-demo
spec:
  containers:
  - name: myboot-demo-1 #<.>
    image: quay.io/rhdevelopers/myboot:v4
    volumeMounts:
    - mountPath: /tmp/demo
      name: demo-volume

  - name: myboot-demo-2 #<.>
    image: quay.io/rhdevelopers/myboot:v4 #<.>

    env:
    - name: SERVER_PORT #<.>
      value: "8090"

    volumeMounts:
    - mountPath: /tmp/demo
      name: demo-volume

  volumes:
  - name: demo-volume #<.>
    emptyDir: {}
----
NOTE: 
<.> Pod의 첫 번째 컨테이너는 myboot-demo-1이라고 하며 `/tmp/demo`에 `demo-volume`을 마운트합니다.
<.> Pod의 두 번째 컨테이너는 `myboot-demo-2`라고 하며 동일한 `/tmp/demo` 지점에 `demo-volume`을 마운트합니다.
<.> 두 컨테이너 모두 동일한 이미지를 사용합니다.
<.> 컨테이너는 Pod의 포트를 공유하므로 두 번째 컨테이너는 첫 번째 컨테이너와 다른 포트에서 수신 대기해야 합니다.  이 수준의 `env` 지시문은 `myboot-demo-2` 컨테이너에만 적용됩니다.
<.> 볼륨은 한 번만 정의되지만 Pod의 각 컨테이너에서 참조됩니다.

이제 프로젝트에 해당 Deployment를 생성해 보겠습니다.

[.console-input]
[source,bash]
----
cat <<EOF | oc create -f -
apiVersion: v1
kind: Pod
metadata:
  name: myboot-demo
spec:
  containers:
  - name: myboot-demo-1
    image: quay.io/rhdevelopers/myboot:v4
    volumeMounts:
    - mountPath: /tmp/demo
      name: demo-volume

  - name: myboot-demo-2
    image: quay.io/rhdevelopers/myboot:v4

    env:
    - name: SERVER_PORT
      value: "8090"

    volumeMounts:
    - mountPath: /tmp/demo
      name: demo-volume

  volumes:
  - name: demo-volume
    emptyDir: {}
EOF


----



* *Terminal#2에서 확인*

[.console-output]
[source,bash,subs="+macros,+attributes,+quotes"]
----
NAME          READY   STATUS    RESTARTS   AGE
myboot-demo   #2/2#    Running   0          4s
----

'2/2' 준비 상태를 확인하세요.  이는 Pod 정의에 있는 2개의 컨테이너를 나타냅니다.


먼저 Pod의 *두 번째* 컨테이너로 실행하고 마운트 지점에서 감시를 시작하겠습니다.  이를 위해 Pod의 다른 컨테이너에 또 다른 터미널(*{file-watch-terminal}*) `exec`를 열어 `cat` 명령을 실행합니다.

[.console-input]
[source,bash]
----
oc exec -it myboot-demo -c myboot-demo-2 -- bash 
----

그런 다음 Pod의 `myboot-demo-2` 컨테이너 내부에서 다음 명령을 실행합니다.

[.console-input]
[source,bash]
----
watch -n1 -- "ls -l /tmp/demo && eval ""cat /tmp/demo/greeting.txt"""
----

처음에는 아래와 같이 반환됩니다

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
total 0
cat: /tmp/demo/greeting.txt: No such file or directory
----

 *첫 번째* 컨테이너에 액세스하여 *두 번째* 컨테이너가 볼 수 있는 파일을 생성할 수 있는지 살펴보겠습니다.

* *Terminal#3에서 작업*

[#kubectl-deploy-app]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc project volume-%userid%
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Now using project "volume-%userid%" on server "https://172.30.0.1:443".
----

NOTE: `oc project volume-%userid%` : 현재 활성화된 컨텍스트의 기본 프로젝트를 volume-%userid%로 변경합니다.


[.console-input]
[source,bash]
----
oc exec -ti myboot-demo -c myboot-demo-1 -- /bin/bash
----

그리고 `/tmp/demo` 디렉토리에 일부 콘텐츠를 생성합니다.

[.console-input]
[source,bash]
----
curl localhost:8080/appendgreetingfile
----

그런 다음 파일이 존재하고 해당 내용이 무엇인지 표시합니다.

[.console-input]
[source,bash]
----
ls -l /tmp/demo && echo $(cat /tmp/demo/greeting.txt) 
----

[.console-output]
[source,bash]
----
total 4
-rw-r--r--. 1 root root 5 Jul 13 08:11 greeting.txt
Jambo
----



한편 Terminal#1에는 다음과 같은 내용이 표시됩니다.


[.console-output]
[source,bash,subs="+macros,+attributes"]
----
total 4
-rw-r--r--. 1 root root 5 Jul 13 08:11 greeting.txt
Jambo
----

[CTRL+c]를 눌러 Watch를 종료한 다음 'exec'에서 Pod로 종료합니다.

[.console-input]
[source,bash]
----
exit
----

이제 터미널로 돌아가서 다음을 실행하여 Pod에서 볼륨 정보를 가져올 수 있습니다.

[.console-input]
[source,bash]
----
oc describe pod myboot-demo
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Volumes:
  demo-volume:
    Type:       EmptyDir (a temporary directory that shares a pods lifetime)
    Medium:
    SizeLimit:  <unset>
----


==== Clean Up



`exec` 명령을 종료하세요.

[.console-input]
[source,bash]
----
exit
----


이제 Pod를 삭제하세요.

[.console-input]
[source,bash]
----
oc delete pod myboot-demo
----







=== HostPath


IMPORTANT: 
*hostPath 볼륨 사용 제한* +
OpenShift는 클러스터 노드의 파일 시스템 경로를 컨테이너에 직접 마운트하는 hostPath 볼륨의 사용을 기본적으로 금지합니다. 이는 보안상 중요한 이유 때문입니다.+

*SCC(Secure Context Constraints)* +
OpenShift는 Pod가 특정 보안 컨텍스트 제약 조건(SCC)에 맞아야 실행을 허용합니다. +
기본적으로 사용자는 restricted SCC가 할당되어 있고, 이는 hostPath 볼륨 사용을 허용하지 않습니다.+

*이 실습의 user계정은 admin 권한이 없기 때문에, `HostPath` 부분은 실습하지 않고 검토만 하는 것을 권장합니다.*



`hostPath` 볼륨은 노드 파일 시스템의 파일이나 디렉터리를 Pod에 마운트합니다. 


[source, yaml]
----
apiVersion: v1
kind: Pod
metadata:
  name: myboot-demo
spec:
  containers:
  - name: myboot-demo
    image: quay.io/rhdevelopers/myboot:v4
    
    volumeMounts:
    - mountPath: /tmp/demo
      name: demo-volume

  volumes:
  - name: demo-volume
    hostPath: #<.> 
      path: "/mnt/data" #<.>
----
NOTE: 
<.> 이전과 동일한 위치에 마운트하고 있지만 여기에서는 `emptyDir` 대신 `hostPath`로 볼륨을 정의한 것을 볼 수 있습니다.
<.> `/mnt/data`는 이 Pod가 할당되는 kubernetes `node`의 위치입니다.

이 경우 내용이 저장될 호스트/노드 디렉터리를 정의합니다.

[.console-input]
[source,bash]
----
cat <<EOF | oc create -f -
apiVersion: v1
kind: Pod
metadata:
  name: myboot-demo
spec:
  containers:
  - name: myboot-demo
    image: quay.io/rhdevelopers/myboot:v4
    securityContext:
      privileged: true    
    volumeMounts:
    - mountPath: /tmp/demo
      name: demo-volume

  volumes:
  - name: demo-volume
    hostPath:
      path: "/mnt/data"
EOF
----

이제 볼륨 섹션에서 Pod를 설명하면 다음이 표시됩니다.


[.console-input]
[source,bash]
----
oc describe pod myboot-demo
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Volumes:
  demo-volume:
    Type:          HostPath (bare host directory volume)
    Path:          /mnt/data
    HostPathType:
----


'호스트' 또는 '노드'의 디렉터리를 볼 수 있는 터미널을 열어 보겠습니다.

우선 pod가 배포되어 있는 노드를 확인합니다.


[.console-input]
[source,bash]
----
oc get pod -o wide
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME          READY   STATUS    RESTARTS   AGE     IP            NODE                                       NOMINATED NODE   READINESS GATES
myboot-demo   1/1     Running   0          4m19s   10.131.0.29   ip-10-0-27-23.us-east-2.compute.internal   <none>           <none>
----

노드로  접속합니다.

[.console-input]
[source,bash]
----
oc debug node/ip-10-0-27-23.us-east-2.compute.internal
chroot /host
---

NOTE: oc debug node 명령어는 node를 디버깅하기 위한 pod를 생성하고 노드에 접속합니다.


이제 노드에 있으므로 Pod가 `/tmp/demo`로 마운트한 `{mount-dir}` 디렉터리를 살펴보겠습니다.

[.console-input]
[source,bash]
----
watch -n1 -- "ls -al /mnt/data && eval ""cat /mnt/data/greeting.txt"""
----


[.console-output]
[source,bash,subs="+macros,+attributes"]
----
drwxr-xr-x. 2 root root  6 Dec  7 09:32 .
drwxr-xr-x. 3 root root 18 Dec  7 09:32 ..
cat: /mnt/data/greeting.txt: No such file or directory
----

NOTE: 아직 파일이 확인되지 않습니다.



* *Terminal#3*

파일을 생성해 보겠습니다.


[#kubectl-deploy-app]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc project volume-%userid%
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Now using project "volume-%userid%" on server "https://172.30.0.1:443".
----

NOTE: `oc project volume-%userid%` : 현재 활성화된 컨텍스트의 기본 프로젝트를 volume-%userid%로 변경합니다.



[.console-input]
[source,bash]
----
kubectl exec -ti myboot-demo -- /bin/bash
----

그런 다음 Pod 내에서 '/tmp/demo' 디렉터리에 일부 콘텐츠를 생성합니다.

[.console-input]
[source,bash]
----
curl localhost:8080/appendgreetingfile
----


한편 다른 터미널(*{file-watch-terminal}*)에서는 동시에 watch 출력 변경을 볼 수 있습니다.


[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Every 1.0s: eval ls -al /mnt/da...  devnation: Tue Jul 13 09:14:28 2021

total 4
drwxr-xr-x. 1 root root 24 Jul 13 09:13 .
drwxr-xr-x. 1 root root  8 Jul 13 08:24 ..
-rw-r--r--. 1 root root  5 Jul 13 09:13 greeting.txt
Jambo
----


이제 Pod 내부 `/tmp/demo`에 저장된 콘텐츠는 호스트 경로 `/mnt/data`에 저장되므로 Pod가 죽어도 콘텐츠가 손실되지 않습니다. +
하지만 이렇게 해도 모든 문제가 해결되지는 않을 수 있습니다.  +
Pod가 다운되고 다른 노드에서 다시 예약되면 데이터는 이 다른 노드에 없게 됩니다. 이 경우 Amazon EBS 볼륨에 대한 또 다른 예를 살펴보겠습니다. 

[source, yaml]
----
apiVersion: v1
kind: Pod
metadata:
  name: test-ebs
spec:
...  
  volumes:
    - name: test-volume
      awsElasticBlockStore:
        volumeID: <volume-id>
        fsType: ext4
----

이전 스니펫에서 알아두셔야 할 점은 애플리케이션(예: 컨테이너, 프로브, 포트 등)의 항목과 _dev_ 측면에 더 많은 항목을 클라우드와 더 관련된 항목(예: 물리적)을 혼합하고 있다는 것입니다. +
이러한 개념의 혼합을 피하기 위해 Kubernetes는 일부 추상화 계층을 제공하므로 개발자는 데이터를 저장할 공간(_지속적 볼륨 요청_)만 요청하면 운영 팀은 물리적 스토리지 구성을 제공합니다.

==== Clean Up


[.console-input]
[source,bash]
----
oc delete pod myboot-demo 
---





== Persistent Volume & Persistent Volume Claim

'영구 볼륨'(_PV_)은 관리자가 생성하거나 Pod와 독립적으로 '스토리지 클래스'를 동적으로 사용하여 생성되는 Kubernetes 리소스입니다.
이는 스토리지 구현에 대한 세부 정보를 캡처하며 NFS, Ceph, iSCSI 또는 클라우드 제공업체별 스토리지 시스템일 수 있습니다.

'PertantVolumeClaim'(_PVC_)은 사용자의 스토리지 요청입니다.
특정 볼륨 크기 또는 액세스 모드 등을 요청할 수 있습니다.


=== Persistent volume/claim with hostPath


`hostPath` 전략을 사용하되 이를 볼륨으로 직접 구성하지 않고 영구 볼륨 및 영구 볼륨 클레임을 사용하겠습니다. 


[source, yaml]
.{quick-open-file}
----
kind: PersistentVolume
apiVersion: v1
metadata:
  name: my-persistent-volume
  labels:
    type: local
spec:
  storageClassName: pv-demo 
  capacity:
    storage: 100Mi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/mnt/persistent-volume"
----

이제 '볼륨' 정보는 더 이상 Pod에 있지 않고 _영구 볼륨_ 개체에 있습니다.

[.console-input]
[source,bash]
----
cat <<EOF | oc create -f -
kind: PersistentVolume
apiVersion: v1
metadata:
  name: my-persistent-volume-%userid%
  labels:
    type: local
spec:
  storageClassName: pv-demo 
  capacity:
    storage: 100Mi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/mnt/persistent-volume-%userid%"
EOF
----

[.console-input]
[source,bash]
----
oc get pv -w
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM                                           STORAGECLASS   REASON   AGE
my-persistent-volume-%userid%                       100Mi      RWO            Retain           Available                                                   pv-demo                 5s
----






볼륨이 설정되면 파일 감시 터미널을 업데이트하여 볼륨의 새 위치를 살펴보겠습니다.




다음 새 watch를 시작해 보세요.


* *Terminal#2에서 수행*



[#kubectl-deploy-app]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc project volume-%userid%
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Now using project "volume-%userid%" on server "https://172.30.0.1:443".
----

NOTE: `oc project volume-%userid%` : 현재 활성화된 컨텍스트의 기본 프로젝트를 volume-%userid%로 변경합니다.


우선 pod가 배포되어 있는 노드를 확인합니다.


[.console-input]
[source,bash]
----
oc get pod -o wide
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME          READY   STATUS    RESTARTS   AGE     IP            NODE                                       NOMINATED NODE   READINESS GATES
myboot-demo   1/1     Running   0          4m19s   10.131.0.29   ip-10-0-27-23.us-east-2.compute.internal   <none>           <none>
----

노드로  접속합니다.

[.console-input]
[source,bash]
----
oc debug node/ip-10-0-27-23.us-east-2.compute.internal
chroot /host
---

NOTE: oc debug node 명령어는 node를 디버깅하기 위한 pod를 생성하고 노드에 접속합니다.


이제 노드에 있으므로 Pod가 `/tmp/demo`로 마운트한 `{mount-dir}` 디렉터리를 살펴보겠습니다.

[.console-input]
[source,bash]
----
watch -n1 -- "ls -al /mnt/persistent-volume-%userid% && eval ""cat /mnt/persistent-volume-%userid%/greeting.txt"""
----


[.console-output]
[source,bash,subs="+macros,+attributes"]
----
drwxr-xr-x. 2 root root  6 Dec  7 09:32 .
drwxr-xr-x. 3 root root 18 Dec  7 09:32 ..
cat: /mnt/data/greeting.txt: No such file or directory
----

NOTE: 아직 파일이 확인되지 않습니다.




그런 다음 개발 측에서는 _PV_에서 필요한 것을 요청해야 합니다.
다음 예에서는 *10Mi* 공간을 요청합니다. 


[source, yaml]
.{quick-open-file}
----
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myboot-volumeclaim-%userid%
spec:
  storageClassName: pv-demo 
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Mi
----


[.console-input]
[source,bash]
----
cat <<EOF | oc create -f -
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myboot-volumeclaim-%userid%
spec:
  storageClassName: pv-demo 
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Mi
EOF
----

[.console-input]
[source,bash]
----
oc get pvc -w
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME                 STATUS   VOLUME                 CAPACITY   ACCESS MODES   STORAGECLASS   AGE
myboot-volumeclaim-%userid%   Bound    my-persistent-volume   100Mi      RWO            pv-demo        3s
----





가장 큰 차이점은 이제 Pod에서 볼륨 구성을 직접 정의하는 것이 아니라 사용할 _영구 볼륨 클레임_을 `volumes` 섹션에서 정의한다는 것입니다.



[source, yaml]
----
apiVersion: v1
kind: Pod
metadata:
  name: myboot-demo
spec:
  containers:
  - name: myboot-demo
    image: quay.io/rhdevelopers/myboot:v4
    securityContext:
      privileged: true    
    volumeMounts:
    - mountPath: /tmp/demo
      name: demo-volume

  volumes:
  - name: demo-volume
    persistentVolumeClaim:
      claimName: myboot-volumeclaim
----

[.console-input]
[source,bash]
----
cat <<EOF | oc create -f -
apiVersion: v1
kind: Pod
metadata:
  name: myboot-demo
spec:
  containers:
  - name: myboot-demo
    image: quay.io/rhdevelopers/myboot:v4
    securityContext:
      privileged: true
    volumeMounts:
    - mountPath: /tmp/demo
      name: demo-volume

  volumes:
  - name: demo-volume
    persistentVolumeClaim:
      claimName: myboot-volumeclaim
EOF
----


[.console-input]
[source,bash]
----
oc describe pod myboot-demo
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Volumes:
  demo-volume:
    Type:       PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)
    ClaimName:  myboot-volumeclaim
    ReadOnly:   false
----

이제 Pod 설명에 볼륨이 직접 설정되지 않고 지속적인 볼륨 청구를 통해 설정된다는 내용이 표시됩니다.


[.console-input]
[source,bash]
----
oc exec -ti myboot-demo -- /bin/bash
----

그런 다음 Pod 내에서 '/tmp/demo' 디렉터리에 일부 콘텐츠를 생성합니다.

[.console-input]
[source,bash]
----
curl localhost:8080/appendgreetingfile
----



그리고 이 작업을 완료하자마자 `PerciousVolume`이 매핑되는 노드의 경로에 다음이 표시될 것으로 예상됩니다.


==Terminal#2에서 실행.



[#kubectl-deploy-app]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc project volume-%userid%
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Now using project "volume-%userid%" on server "https://172.30.0.1:443".
----

NOTE: `oc project volume-%userid%` : 현재 활성화된 컨텍스트의 기본 프로젝트를 volume-%userid%로 변경합니다.


우선 pod가 배포되어 있는 노드를 확인합니다.


[.console-input]
[source,bash]
----
oc get pod -o wide
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME          READY   STATUS    RESTARTS   AGE     IP            NODE                                       NOMINATED NODE   READINESS GATES
myboot-demo   1/1     Running   0          4m19s   10.131.0.29   ip-10-0-27-23.us-east-2.compute.internal   <none>           <none>
----

노드로  접속합니다.

[.console-input]
[source,bash]
----
oc debug node/ip-10-0-27-23.us-east-2.compute.internal
chroot /host
---

NOTE: oc debug node 명령어는 node를 디버깅하기 위한 pod를 생성하고 노드에 접속합니다.


이제 노드에 있으므로 Pod가 `/tmp/demo`로 마운트한 `{mount-dir}` 디렉터리를 살펴보겠습니다.

[.console-input]
[source,bash]
----
watch -n1 -- "ls -al /mnt/persistent-volume-%userid% && eval ""cat /mnt/persistent-volume-%userid%/greeting.txt"""
----



[.console-output]
[source,bash,subs="+macros,+attributes"]
----
total 4
drwxr-xr-x. 1 root root 24 Jul 19 14:06 .
drwxr-xr-x. 1 root root 42 Jul 13 09:21 ..
-rw-r--r--. 1 root root  5 Jul 19 14:06 greeting.txt
Jambo
----



==== Clean Up

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc delete pod myboot-demo
----

모든 것이 정리되면 다음을 실행하십시오.


[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc get pvc
----

Results in:

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME                 STATUS   VOLUME                 CAPACITY   ACCESS MODES   STORAGECLASS   AGE
myboot-volumeclaim-%userid%   Bound    my-persistent-volume   100Mi      RWO            pv-demo        14m
----

Pod가 삭제되었더라도 PVC(및 PV)는 여전히 존재하므로 수동으로 삭제해야 합니다.

[.console-input]
[source,bash]
----
oc delete pvc myboot-volumeclaim-%userid%
oc delete pv my-persistent-volume-%userid%
----







== Static vs Dynamic Provisioning

영구 볼륨은 동적으로 또는 정적으로 프로비저닝될 수 있습니다.

정적 프로비저닝을 통해 클러스터 관리자는 *기존* 저장 장치를 클러스터에서 사용할 수 있도록 할 수 있습니다.
이런 방식으로 완료되면 PV와 PVC를 수동으로 제공해야 합니다.

지금까지 마지막 예에서는 정적 프로비저닝을 살펴보았습니다.

동적 프로비저닝을 사용하면 클러스터 관리자가 스토리지를 사전 프로비저닝할 필요가 없습니다.
대신 사용자가 요청할 때 자동으로 스토리지를 프로비저닝합니다.
이를 실행하려면 스토리지 클래스 객체와 이를 참조하는 PVC를 제공해야 합니다.
PVC가 생성되면 스토리지 디바이스와 PV가 자동으로 생성됩니다.
동적 프로비저닝의 주요 목적은 클라우드 제공업체 솔루션과 협력하는 것입니다.

일반적으로 Kubernetes 구현은 누구나 동적 프로비저닝을 빠르게 시작할 수 있도록 기본 스토리지 클래스를 제공합니다.
다음을 실행하여 기본 스토리지 클래스에서 정보를 얻을 수 있습니다.

[.console-input]
[source,bash]
----
oc get sc
----


[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME            PROVISIONER             AGE
gp2 (default)   kubernetes.io/aws-ebs   31h
----

기본적으로 OpenShift가 클라우드 공급자에 설치되면 클라우드의 기본 영구 기술을 사용하여 스토리지 클래스가 자동으로 생성됩니다. +
예를 들어 AWS의 경우 AWS EBS를 가리키는 기본 스토리지 클래스가 제공됩니다.

그런 다음 영구 볼륨을 자동으로 생성하는 영구 볼륨 신청을 생성할 수 있습니다.  

[source, yaml]
----
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myboot-volumeclaim-%userid%
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Mi
----

_storage 클래스_를 지정하지 않았지만 기본값으로 정의된 클래스가 있으므로 _PVC_는 암시적으로 해당 클래스를 참조합니다. +
(이 Pod 정의를 `myboot-pertant-volume-claim.yaml`과 비교하는 것을 고려해 볼 수 있습니다)



.정적 PVC와 동적 PVC의 차이점(정적 PV 포함)
image::2-9.png[2-9]

[.console-input]
[source,bash]
----
cat <<EOF | oc create -f -
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myboot-volumeclaim-%userid%
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Mi
EOF

----

[.console-input]
[source,bash]
----
oc get pvc
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME                 STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE
myboot-volumeclaim-%userid%   Pending                                      gp2            46sç
----


_PVC_는 _Pending_ 상태입니다. 동적 스토리지를 생성 중이라는 점과 _pod_가 볼륨을 요청하지 않는 동안 _PVC_는 보류 상태로 유지되고 _PV_는 생성되지 않음을 의미하기 때문입니다.

[.console-input]
[source,bash]
----
cat <<EOF | oc create -f -
apiVersion: v1
kind: Pod
metadata:
  name: myboot-demo
spec:
  containers:
  - name: myboot-demo
    image: quay.io/rhdevelopers/myboot:v4
    securityContext:
      privileged: true
    volumeMounts:
    - mountPath: /tmp/demo
      name: demo-volume

  volumes:
  - name: demo-volume
    persistentVolumeClaim:
      claimName: myboot-volumeclaim-%user1%
EOF
----



* *Terminal#2에서 수행*

[.console-input]
[source,bash]
----
oc get pods
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME          READY   STATUS    RESTARTS   AGE
myboot-demo   1/1     Running   0          2m36s
----

Pod가 _Running_ 상태이면 _PVC_ 및 _PV_ 매개변수를 가져올 수 있습니다.

[.console-input]
[source,bash]
----
oc get pvc
----


[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME                 STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
myboot-volumeclaim-%userid%   Bound    pvc-6de4f27e-bd40-4b58-bb46-91eb08ca5bd7   1Gi        RWO            gp2            116s
----



이제 볼륨 청구가 볼륨에 _Bound_되었습니다.

마지막으로 _PV_가 자동으로 생성되었는지 확인할 수 있습니다.

[.console-input]
[source,bash]
----
oc get pv
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                        STORAGECLASS   REASON   AGE
pvc-170f2e9a-4afc-4869-bd19-f10c86bff34b   10Mi       RWO            Delete           Bound    myspace/myboot-volumeclaim   standard                56s
----


[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                        STORAGECLASS   REASON   AGE
pvc-6de4f27e-bd40-4b58-bb46-91eb08ca5bd7   1Gi        RWO            Delete           Bound    default/myboot-volumeclaim   gp2                     77s
----


_CLAIM_ 필드는 _PV_ 생성을 담당하는 _PVC_를 가리킵니다.

=== Clean Up

[.console-input]
[source,bash]
----
oc delete pod myboot-demo
oc delete pvc myboot-volumeclaim-%userid% 
----

== 분산 파일 시스템

클라우드 제공업체는 분산 스토리지를 제공하므로 모든 노드에서 데이터를 항상 사용할 수 있다는 점에 유의하는 것이 중요합니다.
마지막 예에서 본 것처럼 이 스토리지 클래스는 모든 노드가 동일한 디스크 콘텐츠를 볼 수 있도록 보장합니다.

예를 들어 온프레미스에서 Kubernetes/OpenShift를 사용 중이거나 공급업체 솔루션으로 릴레이하지 않으려는 경우 Kubernetes에서 분산 파일 시스템도 지원됩니다.
그렇다면 NFS, https://www.gluster.org/[GlusterFS ] 또는 https://ceph.io/[Ceph]를 사용하는 것이 좋습니다.
